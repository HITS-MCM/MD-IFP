# MD-IFP: MD trajectory analysis using protein-ligand Interaction Fingerprints
## A Python workflow for generation and analysis Protein-Ligand Interaction Fingerprints from Molecular Dynamics tajectories

__Authors:__

* Daria Kokh
* Fabian Ormersbach - preprocessing PDB files using Chimera (Process_pdb.py, chimera_hydrogen_mol2.py; test examples revised) 


Heidelberg Institute of Theoretical Studies (HITS, www.h-its.org)

Schloss-Wolfsbrunnenweg 35

69118 Heidelberg, Germany
    

*This open source software code was developed in part in the __Human Brain Project__, funded from the European Union’s Horizon 2020 Framework Programme for Research and Innovation under Specific Grant Agreements  No. 785907 (Human Brain Project  SGA2).*


# __I. Important notes regarding the file preparation procedure for IFP computations:__

## Ligand structure
  1. __Ligand must be protonated__. For analysis of multiple structures, one can use the automated procedure implemented in the script Process_pdb.py that employs the Chimera software (https://www.cgl.ucsf.edu/chimera/). 
  2. The ligand structure should be provided as a  __MOL2 file__. However, not all mol2 formats are accepted by RDKit (the Python library that is used to determine ligand atom properties). The main problem with mol2 files generated by Chimera is that it often incorrectly describes bonds in aromatic or cyclic groups that contain nitrogen atoms. The mol2 file generated can in some cases be corrected by using http://www.swissparam.ch/. The best way to generate a mol2 file is to use the MOE or Maestro software.
  3. If mol2 file is absent or is not accepted by RDKit, pdb file will be used to define properies of ligand atoms. Unfortunately, in this case aromatic fragments will not be identified.
  4. There are several atom properties that are introduced in addition to those identified by RDKit:
      - Hydrophobic properties of fluorine atoms
      -  Negative ion property of the phosphate atom
      -  Acceptor property of the oxygen atoms bound to phosphorus atoms in phosphate groups
  5. __Important__, the name of the ligand in mol2 file (or the residue name in the pdb file if mol2 is absent) is used to detect ligand in a trajectory or in a complex. If the residue name is different - IFP will not be computed!
  6. __Important__: sometimes RDkit does not recognize ligand properties correctly, they can be checked and corrected if necessary:
  
    #  reading ligand input file and generating ligand chemical properties :
    my_ligand = Ligand("./",ligand_pdb,ligand_mol2)
    properties = my_ligand.property_list
    #  checking properties
    print("Ligand properties: ",properties
    #...............Ligand properties:................
    # Acceptor ['O09', 'O12']
    # PosIonizable ['N02']
    # Hydrophobe ['C14', 'C06', 'C07']
    #   correcting properties: let define atom N02 as one more  acceptor atom, for this we can re-define properties['Acceptor'] as:
    properties['Acceptor'] = ['O09', 'O12','N02']
    # then we can run IFP generation as usual, passing new properties as an input parameter:
    df_prop,df_HB,df_WB = IFP(u_mem, sel_ligands, properties, WB_analysis=True)
  
 ## Complex structure/trajectory 
   1. __System (protein/ligand/water) must be protonated__. This is nessesary for detection of hydrogen bonds.
   2. __Finding ligand contacts with ions/RNA/etc__.To minimize the memory and computational time required, only a part of the system is analyzed (defined by a variable sub_system). By default, this is protein+water+ligand. Interactions (H-bonds) with DNA/RNA and ions can be found only if their residues are explicitly defined in by the sub_system variable of the trajectories class. Alternatively, one can speed-up computqtions by keeping only protein as a sub_system. For example:
     
     # by default protein, ligand and water are considered
     # consider only protein and ligand 
     tr = trajectories()
     tr.sub_system = " proteins "
     tr.analysis_all_namd()
     
     # consider only protein, water, ligand, RRN, and some ions
     tr = trajectories()
     tr.sub_system = "protein or (resname G G3 G5 U5 C C3 MG MN CA Mg Mn) or (resname WAT HOH SOL)"
     tr.analysis_all_namd()

   
   3. For computation of IFP in a trajectory, protein (reference) structure in a pdb format must be provided in addition to a trajectory file. It must have the same structure. Note, that RMSD computed will be relative to the reference structure (not the first frame).
   4. Currently, Gromacs trajectories (as xtc) must be pre-processed in order to build back molecules that can be splitted due to the motion under PBC. Trajectory analysis does not do this properly (to be fixed in future) One can use the following command:
   
    gmx trjconv -f ramd_trj.xtc  -s ramd_tpr.tpr  -pbc mol -o ramd_trj_fixed.xtc  <<< 0
    or to save only starting from 500ps:
    gmx trjconv -f ramd_trj.xtc  -s ramd_tpr.tpr  -pbc mol -o ramd_trj_fixed.xtc  -b + 500 <<< 0
    
   
   
 # __II. Structure of the MD-IFP library:__

## A set of  Python scripts  collected in the directory Scripts

   1. Trajectories.py
   2. IFP_generation.py
   3. Clustering.py
   
  
 # __III. Generation of the Interaction Fingerprint table for a set of MD trajectories obtained either from standard MD simulations or RAMD simulations__
Most steps included in the present examples are also demonstrated in the JN IFP_generation_examples_TRAJ.ipynb
However, to analyze a large set of trajectories a simple python script is usually more useful.

This example provide a template script that, after small adjustment, can be used to generate IFPs for: 
- a single MD trajectory    
- a set of MD trajectories. 
- a set of Equilibration MD trajectories and dissociation RAMD trajectries
    
    
    
All steps are also included in IFP.py, that can be adjusted for a particular task

1. **Prerequisite:**
    - Python 3.X and a set of python libraries
        Alteratively, one can configure environment in anaconda using: conda env create -f IFP_trajectory.yml
    - Scripts directory containing Scripts/IFP_generation.py and Scripts/Trajectories.py 
    
2. **Input data required:**
    - trajectory file (possible formats: nc,dcd, xtc, trr )
    - pdb file of the system (for example, generated from the first frame)
    - ligand pdb file
    - ligand mol2 file (not all mol2 files can be read, files generated by MOE or corrected by http://www.swissparam.ch/ are usually fine)
         
3. **Procedure (all steps are also combined in the IFP.py script that can be adapted for a particular task )**
 
    (i) _working directory and template of trajectory names that will be searched and added to the object are defined._
    
        for example, simulated equilibration and dissociation trajectories can be stored as follows:
        >>for equilibration:
        
        my_ligand/my_equilibration/my_replica1/md1.dcd
        my_ligand/my_equilibration/my_replica2/md2.dcd
        
        >>for dissociation:
        
        my_ligand/my_RAMD/my_replica1/my_trajectory1/md1.dcd
        my_ligand/my_RAMD/my_replica1/my_trajectory2/md2.dcd
        
        my_ligand/my_RAMD/my_replica2/my_trajectory1/md1.dcd
        my_ligand/my_RAMD/my_replica2/my_trajectory2/md2.dcd
        
        >>reference pdb file for the system: 
        
        my_ligand/topology/my_ref.pdb
        
        >>mol2 and pdb files for the ligand:

        my_ligand/topology/my_ligand.pdb
        my_ligand/topology/my_ligand.mol2
  
    In this case we define input parameters as following:
    
    __________________________________
    
        DIR_all = "my_ligand/"
        eq = "my_equilibration/my_replic*"
        ramd = "my_RAMD/my_replic*"
        eq_tr ="my_trajec*/*.dcd"
        ramd_tr = "my_trajec*/*.dcd"
     __________________________________
     
     Note, that the reference pdb file for a complete system  and pdb/mol2 for a ligand are obligatory, while equilibration or RAMD trajectory can be omitted
   
    (ii)_Trajectory object is generated_, 
    
    which contains all information of equilibration and RAMD trajectories. 
    Additionally, ligand structure and chemical properties will be analyzed
    
     __________________________________
     
        tr = trajectories(DIR_all,namd_tmpl= eq, ramd_tmpl= ramd,ligand_pdb=lig_pdb,pdb = ref_pdb,\
                          ligand_mol2=lig_mol2,namd_traj_tmpl = eq_tr,ramd_traj_tmpl = tamd_tr)                   
      __________________________________
      
     (iii) _Defenition of a sub-system to be analyzed_ 
     
      - several possibilities are demonstrated below. 
      - Ligand will be added automatically to any chosen sub-system; 
      - by default only protein will be considered as a sub-system this makes simulations fast, but computations of water bridges will be not possible
      - Inclusion water makes simulations notably (at least several times) slower
     __________________________________
                               
        tr.sub_system = " protein  "                                              # only protein and ligand - default set
        tr.sub_system = " protein or (resname SOL HOH WAT G G3 G5 U5 C C3 MN)  "  # protein, ligand, solvent, RNA residues, and Mn ion
        tr.sub_system = " protein or (resname SOL HOH WAT )  "                    # protein, ligand, solvent, 
     __________________________________
     
   (iv) _IFP generation_ 
   
   (a) _for equilibration trajectories:_ 
      - One can define if water bridges must be computed (WB_analysis = True/False, default-False). 
        For computation of water bridges  water must be included in the sub-system in the previous step
      - number of contacts with lipids (ligand atom-residue distance < 5A) can be computed - lipid residue names are defined as a list, 
        for example: Lipids = ["PC","CHL","PA"]
      - first frame and stride are defined by the parameters step_analysis and start_analysis
        Saving results  in a data frame file (pkl)         
      - as an input parameter file name should be given 
      - results will be stored in a set of pandas DataFrames - individual frame for each trajectory-  tr.namd.traj.df_properties
      - a complete IFP table can be stored as a pkl file using tr.namd.IFP_save() function with a single parameter- file name
        this  function will return a complete pandas DataFrame including all trajectories
     __________________________________
     
        tr.analysis_all_namd(WB_analysis = False, Lipids = [],auxi_selection = [],step_analysis=step, start_analysis=start)  
        IFP_table = tr.namd.IFP_save(file_name)
      _________________________________
     
   (b) _for RAMD trajectories_
      - first relative residence times will be computed (if the number of RAMD trajectories is more than 8)  using the scan_ramd() function
      - then IFPs computed using the function , similar to that described above for equilibration trajectory
        parameters are the same as for the IFP generation for equilibration trajectories
     __________________________________   

        tr.ramd.scan_ramd()
        tr.analysis_all_ramd(WB_analysis = False, Lipids = [],auxi_selection = [],step_analysis=step, start_analysis=start)
        IFP_table = tr.namd.IFP_save(file_name)
        

 # __IV. Getting representative structures for each cluster (generated in IFP_generation_examples_Analysis.ipynb) from RAMD dissociation trajectories__
The final dataframe _df_ext_ (step 6 in the IFP_generation_examples_Analysis.ipynb script) contains information which trajectory/frame belong to which cluster: cluster number is stored in the column _label_; trajectory frame is in the column _time_ (note, that it is not a frame number of the complete original trajectory, but a frame number in the last N frames used to generate IFPs), replica name and the trajectory number are in columns _Repl_ and _Traj_, respectively. The main problem is to figure out how the values _Repl_, _Traj_, and _time_ are associated with a real frame and a real RMAD trajectory.
Unfortunately, this info is not stored in the IFP dataframe and to answer this question one has to do some additional analysis.

 ## 1. Finding the order of RAMD trajectories loaded . 
 First, one has to look at the output of the first step "1. Reading IFP data set for one selected HSP90 compound":  it shows an order of the input pkl files (IFP dataframes) that are loaded in the _df_tot_org_ dataframe. For example, for HSP90 we get 
 
    
        DATA\DATA\HSP90_Gromacs\SAD_3\SAD_3-WB_-RAMD0-300.pkl SAD_3-WB
        DATA\DATA\HSP90_Gromacs\SAD_3\SAD_3-WB_-RAMD1-300.pkl SAD_3-WB
        DATA\DATA\HSP90_Gromacs\SAD_3\SAD_3-WB_-RAMD3-300.pkl SAD_3-WB
        DATA\DATA\HSP90_Gromacs\SAD_3\SAD_3-WB_-RAMD4-300.pkl SAD_3-WB
        DATA\DATA\HSP90_Gromacs\SAD_3\SAD_3-WB_-RAMD5-300.pkl SAD_3-WB
        DATA\DATA\HSP90_Gromacs\SAD_3\SAD_3-WB_-RAMD6-300.pkl SAD_3-WB
        DATA\DATA\HSP90_Gromacs\SAD_3\SAD_3-WB_-RAMD7-300.pkl SAD_3-WB
    
     
   The dataframe _df_tot_org_ contains all trajectories sequentially loaded from this list. Each pkl file may contain IFPs from several replicas and each replica may include several trajectories.
   Thus, each trajectory is associated in the dataframe _df_tot_org_  with a (replica, trajectory) pair stored in the columns _Repl_ and _Traj_ .
   If columns _Repl_ and _Traj_ in the original IFP dataframe of the pkl files  are empty, they will be filled out in the dataframe _df_tot_org_ with new values (as it is done in the case of HSP90).
   To check what values of _Repl_ and _Traj_ in the final _df_tot_org_ dataframe  correspond each trajectory in the pkl files, one can run the following script in the JN:


      
        i = 0
        for Repl in df_tot_org.Repl.unique():
            for Traj in df_tot_org[df_tot_org.Repl == Repl].Traj.unique():
             print (i,Repl,Traj)
                i+=1

      
   The combination (_Repl_, _Traj_) is unique for each trajectory and the total number of trajectories must be the same as loaded from all pkl files. For example, for HSP90 we have altogether 52 trajectories.
   The same _(Repl, Traj)_ values can be found in the final dataframe _df_ext_ that also contains cluster labels. 
   
   The list of trajectories that are included in each pkl file can be stored in the log file of the program used to generate IFPs.
    For example, for HSP90, the first dataframe 


    
     
     
         DATA\DATA\HSP90_Gromacs\SAD_3\SAD_3-WB_-RAMD0-300.pkl
    
 
  contains IFPs for the following trajectories:


    
 
        >>>>>>>>>= 0 RAMD-Gromacs/HSP90/SAD_3//RAMD-NH/TRJ14-0/ETRJ0-2/traj_comp_whole.xtc
        >>>>>>>>>= 1 RAMD-Gromacs/HSP90/SAD_3//RAMD-NH/TRJ14-0/ETRJ0-3/traj_comp_whole.xtc
        >>>>>>>>>= 2 RAMD-Gromacs/HSP90/SAD_3//RAMD-NH/TRJ14-0/ETRJ0-4/traj_comp_whole.xtc
        >>>>>>>>>= 3 RAMD-Gromacs/HSP90/SAD_3//RAMD-NH/TRJ14-0/ETRJ0-5/traj_comp_whole.xtc
        >>>>>>>>>= 4 RAMD-Gromacs/HSP90/SAD_3//RAMD-NH/TRJ14-0/ETRJ0-6/traj_comp_whole.xtc
        >>>>>>>>>= 5 RAMD-Gromacs/HSP90/SAD_3//RAMD-NH/TRJ14-0/ETRJ0-7/traj_comp_whole.xtc
        >>>>>>>>>= 6 RAMD-Gromacs/HSP90/SAD_3//RAMD-NH/TRJ14-0/ETRJ0-8/traj_comp_whole.xtc
        >>>>>>>>>= 7RAMD-Gromacs/HSP90/SAD_3//RAMD-NH/TRJ14-0/ETRJ0-9/traj_comp_whole.xtc
    
      
   Note, that the order of trajectories is important as it is exactly the same in the corresponding pkl file and the total number of trajectories (summed up over all IFP dataframes, see point 1) should be the same as the number of different trajectories (i.e. (_Repl_, _Traj_) , see above)
Thus, one can identify the trajectory from _Repl_ and _Traj_ value of a particular snapshot that you are interested in.

For example, if the first IFP dataframe file  


     
        DATA\DATA\HSP90_Gromacs\SAD_3\SAD_3-WB_-RAMD0-300.pkl 

  
  Contains, according to the log file, 8 trajectories shown above,
and the df_tot_org has the first 7 elements in columns "Repl" and "Traj" :


     
    0 Repl_1 0
    1 Repl_2 0
    2 Repl_3 0
    3 Repl_4 0
    4 Repl_5 0
    5 Repl_6 0
    6 Repl_7 0
    7 Repl_8 1


Thus,  frames with the values Repl_3 and 0 in columns "Repl" and "Traj"", respectively, were generated from the trajectory  


     
       /hits/fast/mcm/kokhda/RAMD-Gromacs/HSP90/SAD_3//RAMD-NH/TRJ14-0/ETRJ0-5/traj_comp_whole.xtc

  

 ## 2. Finding a frame of the RAMD trajectory and generation of a PDB file 
 
 To identify the snapshot of interest, one has to remember that in the IFP analysis only the last N snapshots of a RAMD trajectory are used (usually N=300 or 500 , or a complete trajectory if it’s length is shorter than N). The frame numbering (column time in the  _df_tot_org_ or _df_ext_  dataframe  ) starts from the first frame used to generate IFPs. 
To extract snapshot for a particular frame, you can use different tools. 
For example, MDAnalysis python library:  to extract the frame with time = M from the RAMD tarjectory "traj.xtc" of the length N, one can use the following script:



    import numpy as np
    import MDAnalysis as mda

    u = mda.Universe(refernce.pdb)
    u.load_new("traj.xtc")
    u_length = len(u.trajectory)
    u.trajectory[np.max(0,u_length-N)+M]
    system_reduced = u.select_atoms(" protein or resname INH")
    system_reduced.write("output.pdb")

      

where refernce.pdb - the same reference file that was used to generate IFP, N- the number  of the frames used to generate IFPs, "INH" - residue name of the ligand.
 

